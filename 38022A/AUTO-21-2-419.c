#pragma config(Sensor, port3,  RFcolor,        sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port4,  tLED,           sensorVexIQ_LED)
#pragma config(Sensor, port8,  balanceGyro,    sensorVexIQ_Gyro)
#pragma config(Sensor, port10, turnGyro,       sensorVexIQ_Gyro)
#pragma config(Sensor, port11, LFcolor,        sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor2,          xMotor,        tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor7,          armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          pickMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         ballMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
Author:
       stefan stefan1992@qq.com
Description:
       for the vex iq competition crossover
*/
static int threshold=130;
static int tgd=0;
static int bgd=0;
static float k=4;
/*void remove()
{
	int x=vexRT[ChC];
	int y=vexRT[ChD];
	int z=vexRT[ChB];

	if(abs(x)>movethreshold&&abs(x)>abs(y))
	{
		motor[xMotor]=x;
	}
	else if(abs(y)>movethreshold&&abs(y)>abs(x)&&abs(z)<movethreshold)
	{
		motor[leftMotor]=y;
		motor[rightMotor]=y;
	}
	else if(abs(y)>movethreshold&&abs(y)>abs(x)&&abs(z)>movethreshold)
	{
		motor[leftMotor]=y+z;
		motor[rightMotor]=y-z;
	}
	else if(abs(z)>movethreshold)
	{
		motor[leftMotor]=z;
		motor[rightMotor]=-z;
	}
	else
	{
		motor[leftMotor]=0;
		motor[rightMotor]=0;
		motor[xMotor]=0;
	}
}



void pick()
{
	motor[pickMotor]=vexRT[BtnRUp]*100-vexRT[BtnRDown]*100;
}

void hang()
{
	motor[larmMotor]=vexRT[BtnLUp]*100-vexRT[BtnLDown]*100;
	motor[rarmMotor]=vexRT[BtnLUp]*100-vexRT[BtnLDown]*100;
}*/

void encoderclear()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(xMotor);
	resetMotorEncoder(armMotor);
	resetMotorEncoder(ballMotor);
	resetMotorEncoder(pickMotor);
}

void moveforward(int speed)
{
	if(nMotorEncoder(rightMotor)>nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed;
		motor[rightMotor]=speed-10;
	}
	if (nMotorEncoder(rightMotor)<nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed-10;
		motor[rightMotor]=speed;
	}
	if (nMotorEncoder(rightMotor)==nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed;
		motor[rightMotor]=speed;
	}
}

void moveback(int speed1)
{
	if(nMotorEncoder(rightMotor)>nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed1;
		motor[rightMotor]=speed1-15;
	}
	else if (nMotorEncoder(rightMotor)<nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed1-15;
		motor[rightMotor]=speed1;
	}
	else
	{
		motor[leftMotor]=speed1;
		motor[rightMotor]=speed1;
	}
}

void movehorizon(int speed)
{
	motor[xMotor]=speed;
}

void XcountlineRFcolor(int s,int number )
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[xMotor]=s;

		if (SensorValue(RFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}
}

void XcountlineLFcolor(int s,int number)
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[xMotor]=s;

		if (SensorValue(LFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}
}

void Uarm(int armspeed,int armEncoder)
{
	resetMotorEncoder(armMotor);
	clearTimer(T4);
	while((armEncoder-abs(getMotorEncoder(armMotor)))>0&&time1(T4)<3000)
	{
		motor[armMotor]=armspeed;
	}
	motor[armMotor]=0;
}

void Darm(int bspeed,int bEncoder)
{
	resetMotorEncoder(ballMotor);
	clearTimer(T4);
	while((bEncoder-abs(getMotorEncoder(ballMotor)))>0&&time1(T4)<3000)
	{
		motor[ballMotor]=bspeed;
	}
	motor[ballMotor]=0;
}

void pickarm(int pspeed,int pEncoder)
{
	resetMotorEncoder(pickMotor);
	clearTimer(T4);
	while((pEncoder-abs(getMotorEncoder(pickMotor)))>0&&time1(T4)<2000)
	{
		motor[pickMotor]=pspeed;
	}
	motor[pickMotor]=0;
}

void goX(int xspeed,int xEncoder )
{
	resetMotorEncoder(xMotor);
	clearTimer(T3);
	while(xEncoder-abs(getMotorEncoder(xMotor))>0&&time1(T3)<3000)
	{
		motor[xMotor]=xspeed;
	}
	motor[xMotor]=0;
}

void goY(int yspeed,int yEncoder)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	clearTimer(T2);
	while(yEncoder>abs(getMotorEncoder(leftMotor))&&time1(T2)<3000)
	{
		motor[leftMotor]=yspeed;
		motor[rightMotor]=yspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}

void goGY(int gspeed,int gEncoder,int k2)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	clearTimer(T2);
	tgd=SensorValue(turnGyro);
	while(gEncoder-abs(getMotorEncoder(leftMotor))>0&&time1(T2)<3000)
	{
		motor[leftMotor]=k2*(SensorValue[turnGyro-tgd])+gspeed;
		motor[rightMotor]=k2*(tgd-SensorValue[turnGyro])+gspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}
void GyroTurn(int tspeed,int tgyro)
{
	tgd=SensorValue(turnGyro);
	clearTimer(T1);
	while(abs(SensorValue(turnGyro)-tgd)<tgyro&&time1(T1)<3000)
	{
		motor[leftMotor]=tspeed;
		motor[rightMotor]=-1*tspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}
void stopmove()
{
	motor[leftMotor]=0;
	motor[rightMotor]=0;
	motor[xMotor]=0;
}
void gopick()
{
	moveforward(100);
	wait1Msec(800);
	moveback(-100);
	wait1Msec(200);
	moveforward(100);
	wait1Msec(1300);
	stopmove();
}



void pickupanddown()
{
	setMotorBrakeMode(pickMotor,motorHold);
	pickarm(100,270);
	motor[pickMotor]=100;
	wait1Msec(300);

	motor[pickMotor]=-100;
	wait1Msec(1000);
	motor[pickMotor]=0;

	setMotorBrakeMode(pickMotor,motorCoast);
	wait1Msec(50);
	setMotorBrakeMode(pickMotor,motorHold);
	motor[pickMotor]=0;

}

void climb()
{
	bgd=sensorvalue(balanceGyro);
	encoderclear();
	while(abs(nMotorEncoder[leftMotor])<500)
	{
		motor[leftMotor]=k*(SensorValue[turnGyro-tgd])-90;
		motor[rightMotor]=k*(tgd-SensorValue[turnGyro])-90;
	}
	clearTimer(T4);
	while(SensorValue(balanceGyro)-bgd>-3 && time1(T4)<4000)
	{
	motor[leftMotor]=k*(SensorValue[turnGyro-tgd])-90;
	motor[rightMotor]=k*(tgd-SensorValue[turnGyro])-90;
	}
	stopmove();
}

void climbbalance()
{
	bgd=SensorValue(balanceGyro);
	encoderclear();
	while(SensorValue(balanceGyro)-bgd<14)
	{
		moveback(-60);
	}
	stopmove();
	goY(-40,480);
	clearTimer(T1);
	while(time1(T1)<8000)
	{
		if(SensorValue(balanceGyro)-bgd>9)
		{
			goGY(-40,40,2);
			wait1Msec(200);
		}
		else if(SensorValue(balanceGyro)-bgd<-9)
		{
			goGY(40,40,2);
			wait1Msec(200);
		}
		else
		{
			motor[leftMotor]=0;
			motor[rightMotor]=0;
		}
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}

task Upullball()
{
	Uarm(80,400);
	wait1Msec(500);
	Uarm(-100,300);

}

task Dpullball()
{
	Darm(100,400);
}
task PUD()
{
	pickupanddown();
}

void auto60()
{
	resetGyro(balanceGyro);
	resetGyro(turnGyro);
	wait1Msec(1500);
	while(1){if(getTouchLEDValue(tLED)==1){break;}}

	goY(100,20);
	GyroTurn(60,85);
	goX(100,200);
	motor[xMotor]=30;
	motor[pickMotor]=-100;
	motor[armMotor]=-50;
	motor[ballMotor]=-50;
	wait1Msec(500);
	motor[pickMotor]=0;
	motor[armMotor]=0;
	motor[ballMotor]=0;
	setMotorBrakeMode(pickMotor,motorCoast);
	wait1Msec(50);
	setMotorBrakeMode(pickMotor,motorHold);
	motor[pickMotor]=-15;

	gopick();
	goY(-100,600);
	startTask(PUD);
	//pickupanddown();
	XcountlineRFcolor(-60,1);
	goX(30,20);
	gopick();
	goY(-100,600);
	Uarm(80,240);
	startTask(PUD);
	//pickupanddown();
	goX(-60,220);
	XcountlineLFcolor(-60,1);
	goX(30,20);
	gopick();
	goY(-100,550);
	startTask(PUD);
	//pickupanddown();


	movehorizon(30);
	wait1Msec(500);
	movehorizon(100);
	wait1Msec(2500);
	tgd=(SensorValue[turnGyro]);
	XcountlineLFcolor(-60,1);
	goX(-60,200);
	XcountlineRFcolor(-60,1);

	goX(30,20);
	climb();

	goY(-100,800);
	movehorizon(-100);
	wait1Msec(2500);
	stopmove();
	XcountlineRFcolor(60,1);
	goX(60,200);
	XcountlineRFcolor(60,1);
	goX(-30,20);

	moveback(-100);
	wait1Msec(1500);
	stopmove();
	startTask(Upullball);
	wait1Msec(1000);
	goY(100,100);
	wait1Msec(1000);
	startTask(Dpullball);
	wait1Msec(1000);
	goY(50,50);
	goY(-100,100);

	goY(100,600);
	GyroTurn(60,175);
	movehorizon(100);
	wait1Msec(2500);
	movehorizon(-100);
	wait1Msec(500);
	movehorizon(100);
	wait1Msec(800);
	tgd=SensorValue(turnGyro);
	XcountlineLFcolor(-60,1);
	goX(-60,200);
	XcountlineLFcolor(-60,1);
	goX(30,20);
	pickarm(30,50);
	climbbalance();



}

task main()
{
	auto60();
	while(1){}
}
