#pragma config(Sensor, port3,  balanceGyro,    sensorVexIQ_Gyro)
#pragma config(Sensor, port5,  LFcolor,        sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  turnGyro,       sensorVexIQ_Gyro)
#pragma config(Sensor, port10, tLED,           sensorVexIQ_LED)
#pragma config(Sensor, port11, RFcolor,        sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor2,          xMotor,        tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor7,          pickMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,          ballMotor,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         armMotor,      tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
Author:
       stefan stefan1992@qq.com
Description:
       for the vex iq competition crossover
*/
static int threshold=130;
//static int movethreshold=15;
static int tgd=0;
static int bgd=0;
static float k=3;
/*void remove()
{
	int x=vexRT[ChC];
	int y=vexRT[ChD];
	int z=vexRT[ChB];

	if(abs(x)>movethreshold&&abs(x)>abs(y))
	{
		motor[xMotor]=x;
	}
	else if(abs(y)>movethreshold&&abs(y)>abs(x)&&abs(z)<movethreshold)
	{
		motor[leftMotor]=y;
		motor[rightMotor]=y;
	}
	else if(abs(y)>movethreshold&&abs(y)>abs(x)&&abs(z)>movethreshold)
	{
		motor[leftMotor]=y+z;
		motor[rightMotor]=y-z;
	}
	else if(abs(z)>movethreshold)
	{
		motor[leftMotor]=z;
		motor[rightMotor]=-z;
	}
	else
	{
		motor[leftMotor]=0;
		motor[rightMotor]=0;
		motor[xMotor]=0;
	}
}



void pick()
{
	motor[pickMotor]=vexRT[BtnRUp]*100-vexRT[BtnRDown]*100;
}

void hang()
{
	motor[larmMotor]=vexRT[BtnLUp]*100-vexRT[BtnLDown]*100;
	motor[rarmMotor]=vexRT[BtnLUp]*100-vexRT[BtnLDown]*100;
}*/
void encoderclear()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(xMotor);
	resetMotorEncoder(ballMotor);
	resetMotorEncoder(armMotor);
	resetMotorEncoder(pickMotor);
}
void moveforward(int speed)
{
	if(nMotorEncoder(rightMotor)>nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed;
		motor[rightMotor]=speed-10;
	}
	if (nMotorEncoder(rightMotor)<nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed-10;
		motor[rightMotor]=speed;
	}
	if (nMotorEncoder(rightMotor)==nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed;
		motor[rightMotor]=speed;
	}
}

void moveback(int speed1)
{
	if(nMotorEncoder(rightMotor)>nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed1;
		motor[rightMotor]=speed1-15;
	}
	else if (nMotorEncoder(rightMotor)<nMotorEncoder(leftMotor))
	{
		motor[leftMotor]=speed1-15;
		motor[rightMotor]=speed1;
	}
	else
	{
		motor[leftMotor]=speed1;
		motor[rightMotor]=speed1;
	}
}







void XcountlineRFcolor(int s,int number )
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[xMotor]=s;

		if (SensorValue(RFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}
}
void XcountlineLFcolor(int s,int number)
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[xMotor]=s;

		if (SensorValue(LFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}
}
void YcountlineRFcolor(int s,int number )
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[leftMotor]=s;
		motor[rightMotor]=s;

		if (SensorValue(RFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}

		motor[leftMotor]=0;
		motor[rightMotor]=0;

}

void YcountlineLFcolor(int s,int number )
{
	int lastSeen=1;
	int countValue=0;
	clearTimer(T1);
	while(countValue<number&&time1(T1)<3000)
	{
		motor[leftMotor]=s;
		motor[rightMotor]=s;

		if (SensorValue(LFcolor) < threshold)
		{
			if (lastSeen == 1)
			{
				countValue = countValue + 1;
				lastSeen = 0;
			}
		}
		else
		{
			lastSeen = 1;
		}
	}

		motor[leftMotor]=0;
		motor[rightMotor]=0;

}
void arm(int armspeed,int armEncoder)
{
	resetMotorEncoder(armMotor);
	clearTimer(T4);
	while((armEncoder-abs(getMotorEncoder(armMotor)))>0&&time1(T4)<3000)
	{
		motor[armMotor]=armspeed;
	}
	motor[armMotor]=0;
}
void pickarm(int pspeed,int pEncoder)
{
	resetMotorEncoder(pickMotor);
	clearTimer(T4);
	while((pEncoder-abs(getMotorEncoder(pickMotor)))>0&&time1(T4)<3000)
	{
		motor[pickMotor]=pspeed;
	}
	motor[pickMotor]=0;

}

void ballarm(int bspeed,int bEncoder)
{
	resetMotorEncoder(ballMotor);
	clearTimer(T4);
	while(bEncoder>abs(getMotorEncoder(ballMotor))&&time1(T4)<3000)
	{
		motor[ballMotor]=bspeed;
	}
	motor[ballMotor]=0;
}

void goX(int xspeed,int xEncoder )
{
	resetMotorEncoder(xMotor);
	clearTimer(T3);
	while(xEncoder-abs(getMotorEncoder(xMotor))>0&&time1(T3)<3000)
	{
		motor[xMotor]=xspeed;
	}
	motor[xMotor]=0;
}

void goY(int yspeed,int yEncoder)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	clearTimer(T2);
	while(yEncoder-abs(getMotorEncoder(leftMotor))>0&&time1(T2)<3000)
	{
		motor[leftMotor]=yspeed;
		motor[rightMotor]=yspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}

void goGY(int gspeed,int gEncoder)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	clearTimer(T2);
	tgd=SensorValue(turnGyro);
	while(gEncoder-abs(getMotorEncoder(leftMotor))>0&&time1(T2)<3000)
	{
		motor[leftMotor]=k*(SensorValue[turnGyro-tgd])+gspeed;
		motor[rightMotor]=k*(tgd-SensorValue[turnGyro])+gspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}
void GyroTurn(int tspeed,int tgyro)
{
	tgd=SensorValue(turnGyro);
	clearTimer(T1);
	while(abs(SensorValue(turnGyro)-tgd)<tgyro&&time1(T1)<3000)
	{
		motor[leftMotor]=tspeed;
		motor[rightMotor]=-1*tspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}

void firstpick()
{
	moveforward(100);
	wait1Msec(800);
	moveback(-100);
	wait1Msec(200);
	moveforward(100);
	wait1Msec(1000);
}

void secondpick()
{
	moveforward(100);
	wait1Msec(800);
	moveback(-100);
	wait1Msec(200);
	moveforward(100);
	wait1Msec(1000);
}
void stopmove()
{
	motor[leftMotor]=0;
	motor[rightMotor]=0;
	motor[xMotor]=0;
}


void pickupanddown()
{
	pickarm(100,400);
	motor[pickMotor]=100;
	wait1Msec(300);
	pickarm(-100,400);
	motor[pickMotor]=-100;
	wait1Msec(300);
	motor[pickMotor]=0;
}
void climb()
{
	resetGyro(balanceGyro);
	resetGyro(turnGyro);
	wait1Msec(1500);
	tgd=SensorValue(turnGyro);
	bgd=SensorValue(balanceGyro);
	encoderclear();
	while(abs(nMotorEncoder[leftMotor])<500)
	{
		motor[leftMotor]=k*(SensorValue[turnGyro-tgd])-90;
		motor[rightMotor]=k*(tgd-SensorValue[turnGyro])-90;
	}
	clearTimer(T4);
	while(SensorValue(balanceGyro)>-3 && time1(T4)<4000)
	{
	motor[leftMotor]=k*(SensorValue[turnGyro-tgd])-90;
	motor[rightMotor]=k*(tgd-SensorValue[turnGyro])-90;
	}
	stopmove();
}
void goGY(int gspeed,int gEncoder,int k2)
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	clearTimer(T2);
	tgd=SensorValue(turnGyro);
	while(gEncoder-abs(getMotorEncoder(leftMotor))>0&&time1(T2)<3000)
	{
		motor[leftMotor]=k2*(SensorValue[turnGyro-tgd])+gspeed;
		motor[rightMotor]=k2*(tgd-SensorValue[turnGyro])+gspeed;
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}
void climbbalance()
{
	bgd=SensorValue(balanceGyro);
	encoderclear();
	while(SensorValue(balanceGyro)-bgd<14)
	{
		moveback(-60);
	}
	stopmove();
	goY(-40,480);
	clearTimer(T1);
	while(time1(T1)<8000)
	{
		if(SensorValue(balanceGyro)-bgd>9)
		{
			goGY(-40,40,2);
			wait1Msec(200);
		}
		else if(SensorValue(balanceGyro)-bgd<-9)
		{
			goGY(40,40,2);
			wait1Msec(200);
		}
		else
		{
			motor[leftMotor]=0;
			motor[rightMotor]=0;
		}
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}

task pud()
{
	pickupanddown();
}


void auto60()
{
	motor[xMotor]=30;
	pickarm(-100,600);
	motor[pickMotor]=-100;
	wait1Msec(600);
	motor[pickMotor]=0;
	firstpick();
	startTask(pud);//first pick
	goY(-100,600);

	XcountlineLFcolor(-60,1);
	stopmove();
	goX(30,20);
	arm(100,200);
	secondpick();
	goY(-100,150);
	startTask(pud);//second pick
	goY(-100,550);


  goX(-60,300);
	XcountlineLFcolor(-60,1);
	goX(30,20);
	stopmove();
	secondpick();
	goY(-100,700);
	ballarm(-100,270);
	startTask(pud);

	goX(100,300);
	motor[xMotor]=100;
	wait1Msec(2000);
	tgd=SensorValue[turnGyro];
	wait1Msec(50);
	XcountlineRFcolor(-60,1);
	goX(-60,250);
	XcountlineRFcolor(-60,1);
	goX(30,10);//change 425

	motor[pickMotor]=50;
	wait1Msec(200);
	motor[pickMotor]=0;


	climb();// shangqiao
	goY(-100,900);

	motor[xMotor]=100;
	wait1Msec(3000);
	XcountlineLFcolor(-60,1);
	goX(-60,200);
	XcountlineLFcolor(-60,1);
	goX(30,20);
	goY(-100,500);
	moveback(-100);
	wait1Msec(500);
	stopmove();
	goY(50,50);
	arm(80,320);
	wait1Msec(200);
	arm(-80,250);//first put ball
	goY(50,50);

	ballarm(-100,450);
	moveback(-100);
	wait1Msec(500);
	goY(80,200);

	ballarm(-100,600);//third put ball
	moveback(-100);
	wait1Msec(1000);
	stopmove();
	goY(80,500);
	GyroTurn(40,180);
	motor[xMotor]=100;
	wait1Msec(2000);
	motor[xMotor]=-100;
	wait1Msec(300);
	motor[xMotor]=100;
	wait1Msec(400);
	tgd=SensorValue(turnGyro);
	goY(-100,150);
	XcountlineLFcolor(-60,1);
	goX(-60,200);
	XcountlineLFcolor(-60,1);
	goX(30,10);
	pickarm(50,100);

	climbbalance();
}

task main()
{
	resetGyro(balanceGyro);
	resetGyro(turnGyro);
	wait1Msec(1500);
	while(1){if(getTouchLEDValue(tLED)==1){break;}}
	auto60();
	while(1){}
}
